{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"SheetShuttle SheetShuttle is a plugin friendly tool that connects Google Sheets and GitHub by allowing the user to post collected data to issue trackers, pull requests, and files. The tool provides and object oriented API and encourages users to utilize it in their applications. SheetShuttle Set Up and Installation Recommended Installation Using pip Manually Building SheetShuttle Running SheetShuttle API Setup Google Sheets Service Account Github Access Token Writing Config Sheets Collector Github Interactions Using Command Line Interface Initialize a New Plugin Running an Existing Plugin Plugin System Contributors \u2728 Set Up and Installation Recommended Installation Using pip SheetShuttle can be installed using Python's package manager pip . By running the following command, SheetShuttle and all its dependencies are installed. pip install sheetshuttle Using this command to install SheetShuttle will ensure that you have the latest most stable version of the tool. Additionally, you will be able to run the tool anywhere on your system using the sheetshuttle command. Manually Building SheetShuttle To get the latest changes from main or other development branches, make sure to clone the project's repository and follow these steps to create Python virtual environment, install dependencies, and build the tool. SheetShuttle uses Poetry to create a Python virtual environment and manage dependencies. For more information about Poetry, check out the documentation . To set up the tool for use, please follow the steps outlined below: 1- Install Poetry: Install Poetry using the steps outlined here . To verify that Poetry was installed successfully run the following: poetry -V The expected output is the version of Poetry installed. 2- Install Python Dependencies: Once Poetry has been installed successfully, clone or download the repository and navigate to the root of the repository. Use the following command to install all the dependencies used by SheetShuttle: poetry install This command might take some time to finish running. Once it is completed, SheetShuttle is ready for use! 3- Build SheetShuttle or Run Using Poetry: After the development environment is ready, you can build an installable .whl file using poetry build command, or continue to use the tool by running poetry run sheetshuttle from the project directory and passing any additional CLI arguments. Running SheetShuttle For a thorough steps refer to this tutorial API Setup SheetShuttle requires authentication tokens for a Google Sheets API service account. A GitHub access token is also needed if some features are used. To set up a service account and get the tokens, please follow the steps below: Google Sheets Service Account This tutorial from 3:35 until 8:20 gives clear and detailed steps on how to create a service account and create an authentication key. However, it includes extra steps that not everyone will need to follow. You can follow the video if preferred or the Sheets API Guide . Once API credentials have been downloaded, there are 2 ways to allow SheetShuttle to use them. Place the downloaded JSON file in the root of the project repository OR create a new .env file and transfer the information from the .json file to the environment file in the following format. Important Note: Values in the .env file must be surrounded by double quotation marks \" otherwise, newline character \\n will cause issues. Note that variable names must be in upper case. TYPE=\"value\" PROJECT_ID=\"value\" PRIVATE_KEY_ID=\"value\" PRIVATE_KEY=\"value\" CLIENT_EMAIL=\"value\" CLIENT_ID=\"value\" AUTH_URI=\"value\" TOKEN_URI=\"value\" AUTH_PROVIDER_X509_CERT_URL=\"value\" CLIENT_X509_CERT_URL=\"value\" Github Access Token If you intend to use SheetShuttle's GitHub interactions features, it is required to create a GitHub access token and place it correctly in the project repository. To create a token, please use the official guide found here . The created token should be granted repo access. Once a token has been created, there are two ways to allow SheetShuttle to use it: Create a json file in the repository root with the following format (note that the gh_access_token key is required): json { \"gh_access_token\": \"paste your token here\" } OR add a variable to the .env file in the following format .env GH_ACCESS_TOKEN=\"paste your token here\" Writing Config SheetShuttle relies on user written YAML configuration to collect data from Google Sheets and organize it in regions. GitHub interactions are also managed by YAML configuration. To read more about the structure of SheetShuttle configuration, please refer to our schema documentation . Sheets Collector Sheets Collector is the component of SheetShuttle that is responsible for making Google Sheets API calls and retrieving data from user specified files and sheets. Additionally, it creates an object oriented structure for regions and sheets of data. In order to use this component, configuration YAML files are needed in the config/sheet_sources directory. Multiple files can be used if multiple sheets are being read at the same time. Github Interactions Another component of SheetShuttle is the GitHub Interaction interface. It is responsible for making API requests to GitHub and posting user specified information to GitHub in the form of issue trackers, ull requests, and files. The user has complete control of this component's behavior through YAML configuration files found in config/github_interactions directory. Multiple files can be used if preferred. Using Command Line Interface After installing SheetShuttle using pip , the command sheetshuttle becomes available to run the tool from any location on your system. To get help on the CLI commands for SheetShuttle, you can always run sheetshuttle --help to get the available options. This section gives additional details on the available subcommands for the tool. Initialize a New Plugin To make the process of creating a new plugin more convenient and less error prone, the init command will create a plugin template that fulfils the structural requirement. sheetshuttle init my_plugin_name This command creates a Python file named my_plugin_name.py in the same directory the command was ran in. This file can then be edited and used as the plugin for SheetShuttle. Running an Existing Plugin The run command is responsible for executing a user defined plugin. It supports a help message that displays all the available arguments and their description. Some of these arguments are required while others are optional. Additionally, most of them already hold a default value that gets used when no value is passed through the command. $ sheetshuttle run --help Usage: sheetshuttle run [OPTIONS] Run sheetshuttle using your custom plugin. Options: -kf, --sheets-keys-file TEXT Path to the Sheets api keys, either .json or .env file [default: .env] -sd, --sheets-config-directory TEXT Directory to get the sheets configuration .yaml files from [default: config/sheet_sources/] -gd, --gh-config-directory TEXT Directory to get the Github configuration .yaml files from [default: config/gh_sources/] -pd, --plugins-directory TEXT Directory to get plugins from [default: plugins/] -pn, --plugin-name TEXT Name of plugin to use for processing [default: default] -ja, --json-args TEXT Path to the JSON file with additional arguments. [Optional] --help Show this message and exit. Plugin System SheetShuttle supports user defined plugins that use the API provided by the tool. These plugins typically follow a specific format where they must contain a run function. When the directory and name of the plugin are provided in the sheetshuttle run command, the plugin is validated and then immediately ran. Contributors \u2728 Thanks goes to these wonderful people ( emoji key ): Noor Buchi \ud83d\udcbb \ud83d\udcd6 \ud83d\udd0c \ud83d\udc40 \u26a0\ufe0f \ud83d\udcc6 Tommy Antle \ud83d\udcd6 \ud83d\udc40 tuduun \ud83d\udcbb \ud83d\udc40 Yanqiao4396 \ud83d\udcbb \ud83d\udc40 Gregory M. Kapfhammer \ud83e\uddd1\u200d\ud83c\udfeb \ud83d\udcc6 \ud83e\udd14 Douglas Luman \ud83e\udd14 \ud83c\udfa8 This project follows the all-contributors specification. Contributions of any kind welcome!","title":"Home"},{"location":"#sheetshuttle","text":"SheetShuttle is a plugin friendly tool that connects Google Sheets and GitHub by allowing the user to post collected data to issue trackers, pull requests, and files. The tool provides and object oriented API and encourages users to utilize it in their applications. SheetShuttle Set Up and Installation Recommended Installation Using pip Manually Building SheetShuttle Running SheetShuttle API Setup Google Sheets Service Account Github Access Token Writing Config Sheets Collector Github Interactions Using Command Line Interface Initialize a New Plugin Running an Existing Plugin Plugin System Contributors \u2728","title":"SheetShuttle"},{"location":"#set-up-and-installation","text":"","title":"Set Up and Installation"},{"location":"#recommended-installation-using-pip","text":"SheetShuttle can be installed using Python's package manager pip . By running the following command, SheetShuttle and all its dependencies are installed. pip install sheetshuttle Using this command to install SheetShuttle will ensure that you have the latest most stable version of the tool. Additionally, you will be able to run the tool anywhere on your system using the sheetshuttle command.","title":"Recommended Installation Using pip"},{"location":"#manually-building-sheetshuttle","text":"To get the latest changes from main or other development branches, make sure to clone the project's repository and follow these steps to create Python virtual environment, install dependencies, and build the tool. SheetShuttle uses Poetry to create a Python virtual environment and manage dependencies. For more information about Poetry, check out the documentation . To set up the tool for use, please follow the steps outlined below: 1- Install Poetry: Install Poetry using the steps outlined here . To verify that Poetry was installed successfully run the following: poetry -V The expected output is the version of Poetry installed. 2- Install Python Dependencies: Once Poetry has been installed successfully, clone or download the repository and navigate to the root of the repository. Use the following command to install all the dependencies used by SheetShuttle: poetry install This command might take some time to finish running. Once it is completed, SheetShuttle is ready for use! 3- Build SheetShuttle or Run Using Poetry: After the development environment is ready, you can build an installable .whl file using poetry build command, or continue to use the tool by running poetry run sheetshuttle from the project directory and passing any additional CLI arguments.","title":"Manually Building SheetShuttle"},{"location":"#running-sheetshuttle","text":"For a thorough steps refer to this tutorial","title":"Running SheetShuttle"},{"location":"#api-setup","text":"SheetShuttle requires authentication tokens for a Google Sheets API service account. A GitHub access token is also needed if some features are used. To set up a service account and get the tokens, please follow the steps below:","title":"API Setup"},{"location":"#google-sheets-service-account","text":"This tutorial from 3:35 until 8:20 gives clear and detailed steps on how to create a service account and create an authentication key. However, it includes extra steps that not everyone will need to follow. You can follow the video if preferred or the Sheets API Guide . Once API credentials have been downloaded, there are 2 ways to allow SheetShuttle to use them. Place the downloaded JSON file in the root of the project repository OR create a new .env file and transfer the information from the .json file to the environment file in the following format. Important Note: Values in the .env file must be surrounded by double quotation marks \" otherwise, newline character \\n will cause issues. Note that variable names must be in upper case. TYPE=\"value\" PROJECT_ID=\"value\" PRIVATE_KEY_ID=\"value\" PRIVATE_KEY=\"value\" CLIENT_EMAIL=\"value\" CLIENT_ID=\"value\" AUTH_URI=\"value\" TOKEN_URI=\"value\" AUTH_PROVIDER_X509_CERT_URL=\"value\" CLIENT_X509_CERT_URL=\"value\"","title":"Google Sheets Service Account"},{"location":"#github-access-token","text":"If you intend to use SheetShuttle's GitHub interactions features, it is required to create a GitHub access token and place it correctly in the project repository. To create a token, please use the official guide found here . The created token should be granted repo access. Once a token has been created, there are two ways to allow SheetShuttle to use it: Create a json file in the repository root with the following format (note that the gh_access_token key is required): json { \"gh_access_token\": \"paste your token here\" } OR add a variable to the .env file in the following format .env GH_ACCESS_TOKEN=\"paste your token here\"","title":"Github Access Token"},{"location":"#writing-config","text":"SheetShuttle relies on user written YAML configuration to collect data from Google Sheets and organize it in regions. GitHub interactions are also managed by YAML configuration. To read more about the structure of SheetShuttle configuration, please refer to our schema documentation .","title":"Writing Config"},{"location":"#sheets-collector","text":"Sheets Collector is the component of SheetShuttle that is responsible for making Google Sheets API calls and retrieving data from user specified files and sheets. Additionally, it creates an object oriented structure for regions and sheets of data. In order to use this component, configuration YAML files are needed in the config/sheet_sources directory. Multiple files can be used if multiple sheets are being read at the same time.","title":"Sheets Collector"},{"location":"#github-interactions","text":"Another component of SheetShuttle is the GitHub Interaction interface. It is responsible for making API requests to GitHub and posting user specified information to GitHub in the form of issue trackers, ull requests, and files. The user has complete control of this component's behavior through YAML configuration files found in config/github_interactions directory. Multiple files can be used if preferred.","title":"Github Interactions"},{"location":"#using-command-line-interface","text":"After installing SheetShuttle using pip , the command sheetshuttle becomes available to run the tool from any location on your system. To get help on the CLI commands for SheetShuttle, you can always run sheetshuttle --help to get the available options. This section gives additional details on the available subcommands for the tool.","title":"Using Command Line Interface"},{"location":"#initialize-a-new-plugin","text":"To make the process of creating a new plugin more convenient and less error prone, the init command will create a plugin template that fulfils the structural requirement. sheetshuttle init my_plugin_name This command creates a Python file named my_plugin_name.py in the same directory the command was ran in. This file can then be edited and used as the plugin for SheetShuttle.","title":"Initialize a New Plugin"},{"location":"#running-an-existing-plugin","text":"The run command is responsible for executing a user defined plugin. It supports a help message that displays all the available arguments and their description. Some of these arguments are required while others are optional. Additionally, most of them already hold a default value that gets used when no value is passed through the command. $ sheetshuttle run --help Usage: sheetshuttle run [OPTIONS] Run sheetshuttle using your custom plugin. Options: -kf, --sheets-keys-file TEXT Path to the Sheets api keys, either .json or .env file [default: .env] -sd, --sheets-config-directory TEXT Directory to get the sheets configuration .yaml files from [default: config/sheet_sources/] -gd, --gh-config-directory TEXT Directory to get the Github configuration .yaml files from [default: config/gh_sources/] -pd, --plugins-directory TEXT Directory to get plugins from [default: plugins/] -pn, --plugin-name TEXT Name of plugin to use for processing [default: default] -ja, --json-args TEXT Path to the JSON file with additional arguments. [Optional] --help Show this message and exit.","title":"Running an Existing Plugin"},{"location":"#plugin-system","text":"SheetShuttle supports user defined plugins that use the API provided by the tool. These plugins typically follow a specific format where they must contain a run function. When the directory and name of the plugin are provided in the sheetshuttle run command, the plugin is validated and then immediately ran.","title":"Plugin System"},{"location":"#contributors","text":"Thanks goes to these wonderful people ( emoji key ): Noor Buchi \ud83d\udcbb \ud83d\udcd6 \ud83d\udd0c \ud83d\udc40 \u26a0\ufe0f \ud83d\udcc6 Tommy Antle \ud83d\udcd6 \ud83d\udc40 tuduun \ud83d\udcbb \ud83d\udc40 Yanqiao4396 \ud83d\udcbb \ud83d\udc40 Gregory M. Kapfhammer \ud83e\uddd1\u200d\ud83c\udfeb \ud83d\udcc6 \ud83e\udd14 Douglas Luman \ud83e\udd14 \ud83c\udfa8 This project follows the all-contributors specification. Contributions of any kind welcome!","title":"Contributors \u2728"},{"location":"Getting_Started/","text":"Getting Started Getting Started What's the point of this? Why SheetShuttle? Before we jump in Code Dependencies Setting up API keys How does SheetShuttle work? Let's start coding Why is this code so messy? Time to write some tests How do I run this thing? Ok, but now what? SheetShuttle needs some fixes Write your own plugins What's the point of this? This guide should help you get started as a developer of SheetShuttle. Specifically, it will help you understand the purpose of the project, clarify some of the reasoning behind the design decisions, and much more. It's inevitable that some details will be missed here, so this should be a living document . Always feel free to update it as the implementation changes and when you have new ideas/questions/requests about the project. Why SheetShuttle? The purpose of SheetShuttle is to create infrastructure to automate: Retrieving data from Google Sheets Processing this data through user-defined plugins Publishing the processed data through different ways on GitHub You might say: \"This is very broad, I don't think much was explained here\", but that's exactly the point. SheetShuttle is simply the infrastructure that allows more specific problems to be solved. We want to allow the user to define their own approach to solving a problem, and use our infrastructure do implement it. With that in mind, SheetShuttle is meant to be plugin-friendly. This means that the user can write their own code and integrate it into SheetShuttle workflow. Before we jump in I know you're really excited to jump in and start coding but we gotta set up few things first. This is not the most fun part, but the good thing is that you'll only have to do it once! Code Dependencies SheetShuttle uses many dependencies that you're likely already familiar with. Tools like Python and poetry are used in many labs and practicals in the CS department and you likely already have some experience with them. If you don't already have these two installed, then you should start by doing that. I recommend installing Python through Pyenv or another equivalent since it makes switching to the right version easier. As for Poetry, you can find the instructions in the official website . It's also worth taking some time to review poetry commands and how they're used. Once you have both, Python and Poetry installed, make sure to run poetry install inside your repository home. This will install all needed dependencies on your Python virtualenv. Setting up API keys Setting up API keys is very important to be able to use SheetShuttle. If you're interested in using the GoogleSheets side, then you must set up a service account and have your authentication token and other information stored on your computer. This guide shows the needed steps to set up a service account. As for the GitHub side of things, you will need a personal access token store on your computer to be able to use the GitHub features of SheetShuttle. This online guide has the steps needed to do that. Make sure to keep all keys and tokens secure. DO NOT commit files containing keys, it will cause a security problem and invalidate your keys. Side note : If you're planning to create Google Sheets service account or get a GitHub access token, I recommend that you use a throwaway account. Do not use your personal Google or GitHub account to avoid any issues that could happen such as loss of personal data or other problems we can't anticipate. How does SheetShuttle work? There are three main components in SheetShuttle: Google Sheets handler, GitHub handler, and the user defined plugin. There are some requirements for the user defined plugin but it could include anything the user wants. As for the two handlers, they provide the API that the user defined plugin can use. Both handlers operate on the same concepts and they share the following: Require configuration file that is either user written or automatically generated Configuration file must follow the schema outlined in the infrastructure of each handler NOTE: The schema guide is a very important resource. You can find it here Each handler iterates through the configuration and makes a series of API requests to send out/retrieve the data specified in the configuration files Let's start coding Now that you know the concept behind SheetShuttle, you can start contributing to the project! Make sure you follow the code of conduct and the contribution guide while you write code and send it for review. Why is this code so messy? A lot of the code in SheetShuttle was written as proof of concept to see that we can implement something that links Google Sheets and GitHub. This means that there is plenty of room to polish it up, refactor, and make it more clear to read and understand. If you find some parts to be confusing, missing documentation, or outright disorganized, feel free to go in and make the necessary changes! Many linters are also included in the project to make sure that you're following industry standards of code hygiene and keeping things clean and tidy. Time to write some tests Testing is very important when you're adding new changes or making fixes to existing problems. We don't want to ship a broken product so we always want to make sure that SheetShuttle is working as expected. The existing test suite covers most of the code in the tool but there is room for improvement. Any changes to the infrastructure code should be accompanies with some testing to validate that things are running correctly. How do I run this thing? After you run poetry install , the command you need is poetry run sheetshuttle <your_arguments> . If you want to know more about the available arguments, you can run poetry run sheetshuttle -h to display the help message. Ok, but now what? SheetShuttle needs some fixes There are some existing open issues in the repository that need to be addressed. Some of them are major problems, and others are smaller ones. This is one of the main priorities to make sure that the infrastructure is bug-free before we start using it. Write your own plugins Once existing issues have been resolved, we can start adding new features in the form of plugins! These plugins can look very different depending on what you want them to do. However, they should probably live somewhere else and not with the infrastructure code. So please don't commit plugins directly to this repository since we're only planning to ship the infrastructure and everything else is an addon.","title":"Getting Started"},{"location":"Getting_Started/#getting-started","text":"Getting Started What's the point of this? Why SheetShuttle? Before we jump in Code Dependencies Setting up API keys How does SheetShuttle work? Let's start coding Why is this code so messy? Time to write some tests How do I run this thing? Ok, but now what? SheetShuttle needs some fixes Write your own plugins","title":"Getting Started"},{"location":"Getting_Started/#whats-the-point-of-this","text":"This guide should help you get started as a developer of SheetShuttle. Specifically, it will help you understand the purpose of the project, clarify some of the reasoning behind the design decisions, and much more. It's inevitable that some details will be missed here, so this should be a living document . Always feel free to update it as the implementation changes and when you have new ideas/questions/requests about the project.","title":"What's the point of this?"},{"location":"Getting_Started/#why-sheetshuttle","text":"The purpose of SheetShuttle is to create infrastructure to automate: Retrieving data from Google Sheets Processing this data through user-defined plugins Publishing the processed data through different ways on GitHub You might say: \"This is very broad, I don't think much was explained here\", but that's exactly the point. SheetShuttle is simply the infrastructure that allows more specific problems to be solved. We want to allow the user to define their own approach to solving a problem, and use our infrastructure do implement it. With that in mind, SheetShuttle is meant to be plugin-friendly. This means that the user can write their own code and integrate it into SheetShuttle workflow.","title":"Why SheetShuttle?"},{"location":"Getting_Started/#before-we-jump-in","text":"I know you're really excited to jump in and start coding but we gotta set up few things first. This is not the most fun part, but the good thing is that you'll only have to do it once!","title":"Before we jump in"},{"location":"Getting_Started/#code-dependencies","text":"SheetShuttle uses many dependencies that you're likely already familiar with. Tools like Python and poetry are used in many labs and practicals in the CS department and you likely already have some experience with them. If you don't already have these two installed, then you should start by doing that. I recommend installing Python through Pyenv or another equivalent since it makes switching to the right version easier. As for Poetry, you can find the instructions in the official website . It's also worth taking some time to review poetry commands and how they're used. Once you have both, Python and Poetry installed, make sure to run poetry install inside your repository home. This will install all needed dependencies on your Python virtualenv.","title":"Code Dependencies"},{"location":"Getting_Started/#setting-up-api-keys","text":"Setting up API keys is very important to be able to use SheetShuttle. If you're interested in using the GoogleSheets side, then you must set up a service account and have your authentication token and other information stored on your computer. This guide shows the needed steps to set up a service account. As for the GitHub side of things, you will need a personal access token store on your computer to be able to use the GitHub features of SheetShuttle. This online guide has the steps needed to do that. Make sure to keep all keys and tokens secure. DO NOT commit files containing keys, it will cause a security problem and invalidate your keys. Side note : If you're planning to create Google Sheets service account or get a GitHub access token, I recommend that you use a throwaway account. Do not use your personal Google or GitHub account to avoid any issues that could happen such as loss of personal data or other problems we can't anticipate.","title":"Setting up API keys"},{"location":"Getting_Started/#how-does-sheetshuttle-work","text":"There are three main components in SheetShuttle: Google Sheets handler, GitHub handler, and the user defined plugin. There are some requirements for the user defined plugin but it could include anything the user wants. As for the two handlers, they provide the API that the user defined plugin can use. Both handlers operate on the same concepts and they share the following: Require configuration file that is either user written or automatically generated Configuration file must follow the schema outlined in the infrastructure of each handler NOTE: The schema guide is a very important resource. You can find it here Each handler iterates through the configuration and makes a series of API requests to send out/retrieve the data specified in the configuration files","title":"How does SheetShuttle work?"},{"location":"Getting_Started/#lets-start-coding","text":"Now that you know the concept behind SheetShuttle, you can start contributing to the project! Make sure you follow the code of conduct and the contribution guide while you write code and send it for review.","title":"Let's start coding"},{"location":"Getting_Started/#why-is-this-code-so-messy","text":"A lot of the code in SheetShuttle was written as proof of concept to see that we can implement something that links Google Sheets and GitHub. This means that there is plenty of room to polish it up, refactor, and make it more clear to read and understand. If you find some parts to be confusing, missing documentation, or outright disorganized, feel free to go in and make the necessary changes! Many linters are also included in the project to make sure that you're following industry standards of code hygiene and keeping things clean and tidy.","title":"Why is this code so messy?"},{"location":"Getting_Started/#time-to-write-some-tests","text":"Testing is very important when you're adding new changes or making fixes to existing problems. We don't want to ship a broken product so we always want to make sure that SheetShuttle is working as expected. The existing test suite covers most of the code in the tool but there is room for improvement. Any changes to the infrastructure code should be accompanies with some testing to validate that things are running correctly.","title":"Time to write some tests"},{"location":"Getting_Started/#how-do-i-run-this-thing","text":"After you run poetry install , the command you need is poetry run sheetshuttle <your_arguments> . If you want to know more about the available arguments, you can run poetry run sheetshuttle -h to display the help message.","title":"How do I run this thing?"},{"location":"Getting_Started/#ok-but-now-what","text":"","title":"Ok, but now what?"},{"location":"Getting_Started/#sheetshuttle-needs-some-fixes","text":"There are some existing open issues in the repository that need to be addressed. Some of them are major problems, and others are smaller ones. This is one of the main priorities to make sure that the infrastructure is bug-free before we start using it.","title":"SheetShuttle needs some fixes"},{"location":"Getting_Started/#write-your-own-plugins","text":"Once existing issues have been resolved, we can start adding new features in the form of plugins! These plugins can look very different depending on what you want them to do. However, they should probably live somewhere else and not with the infrastructure code. So please don't commit plugins directly to this repository since we're only planning to ship the infrastructure and everything else is an addon.","title":"Write your own plugins"},{"location":"Google_API_Setup/","text":"Google API Setup Creating a Service Account Create a Google API project from cloud console Click on select project, or create new project Enable Google Sheets API from the API Menu Create credentials for service accounts with the needed access from the Sheets Overview page click on create credentials Fill the information as shown here Select your service account name This information can be left blank Click on the newly created service account and navigate to the keys tab Click on Add Key and select Create new key Select JSON and click create, a json file will be downloaded in your downloads folder Sharing a File with the Service Account Once a service account has been created, individual Google Sheet files should be shared with the account in order to retrieve data from the sheets. To do that, the share functionality of Google Sheets can be used where the service account email address should be given edit access to the file. Please note that you should use the service account email setup when creating the service account","title":"Google API Setup"},{"location":"Google_API_Setup/#google-api-setup","text":"","title":"Google API Setup"},{"location":"Google_API_Setup/#creating-a-service-account","text":"Create a Google API project from cloud console Click on select project, or create new project Enable Google Sheets API from the API Menu Create credentials for service accounts with the needed access from the Sheets Overview page click on create credentials Fill the information as shown here Select your service account name This information can be left blank Click on the newly created service account and navigate to the keys tab Click on Add Key and select Create new key Select JSON and click create, a json file will be downloaded in your downloads folder","title":"Creating a Service Account"},{"location":"Google_API_Setup/#sharing-a-file-with-the-service-account","text":"Once a service account has been created, individual Google Sheet files should be shared with the account in order to retrieve data from the sheets. To do that, the share functionality of Google Sheets can be used where the service account email address should be given edit access to the file. Please note that you should use the service account email setup when creating the service account","title":"Sharing a File with the Service Account"},{"location":"Schemas/","text":"Config Schemas The examples shown here demonstrate the schemas for configuration read by SheetShuttle. In order for the tool to function with no errors, user written configuration must follow the specified format. Config Schemas Sheets Schema Defining Objects Region Object contains_headers Explained fill Explained types Explained Examples Sheet Object Overall Structure GitHub Interactions Schema Issue Schema Pull Request Schema File Schema Sheets Schema Sheets schema describe the format for configuration used to retrieve Google Sheet data. Defining Objects There are two main nested object structures used in the Sheets schema. Region Object This is the simplest object that does not contain complex nested objects in it. It has the following general structure: name: <string, required> name of the region to create start: <string, required> cell to start from (eg. A1) end: <string, required> cell to end at (eg. H12) contains_headers: <boolean, required> if selected range contains headers in the first row headers: <list of strings, conditional> headers to be used, only required if contains_headers is false fill: <boolean, optional> fill the region with `None` if there are missing values. Defaults to false types: <string or object, optional> data type to use for the whole region or for specific columns. Defaults to `string` Some values in this structure are a bit ambiguous, the following section will provide further explanation on their usage: contains_headers Explained In many cases, the region being retrieved already contains the headers to the data. Set this option to true in order to set the column headers of the resulting Pandas dataframe equal to the first row of the data. In the case that the data does not contain headers, another value headers is required by the schema. It should be a list of strings with the headers of the data. NOTE: The length of the headers list must match the number of columns in the data. Otherwise a Pandas error will be thrown. fill Explained SheetShuttle attempts to deal with missing data, but many limitations exist. The following screenshot shows a dataset with empty cells. Let's see how SheetShuttle allows you to deal with it. When retrieved from the Google Sheets API, the data looks as follows: [ ['Student Name', 'EE1-1', 'EE1-2', 'EE1-3'], ['name1', '85', '0'], ['name2', '100', '1'], ['name3', '100', '1'], ['name4', '100', '0'], ['name5', '100', '1'], ['name6', '100', '1'] ] As seen in the sample output, the missing data simply does not show up in the returned value from the API. By enabling fill , the data is converted to the following and then a dataframe is created using it. [ ['Student Name', 'EE1-1', 'EE1-2', 'EE1-3'], ['name1', '85', '0', None], ['name2', '100', '1', None], ['name3', '100', '1', None], ['name4', '100', '0', None], ['name5', '100', '1', None], ['name6', '100', '1', None] ] The same applies to empty rows, where a row full of None is appended in some cases. Example: [ ['Student Name', 'EE1-1', 'EE1-2', 'EE1-3'], ['name1', '85', '0', None], ['name2', '100', '1', None], ['name3', '100', '1', None], ['name4', '100', '0', None], ['name5', '100', '1', None], ['name6', '100', '1', None], [None, None, None, None] ] None will then get converted to Not a Number NaN values in the resulting Pandas dataframe. A problem with this approach is the following: Using a similar example where the missing data is not in the last row/column as seen here: The resulting data from the API is the following: [ ['Student Name', 'EE1-1', 'EE1-2', 'EE1-3'], ['name1', '85', '', '0'], ['name2', '100', '', '1'], ['name3', '100', '', '0'], ['name4', '100', '', '1'], ['name5', '100', '', '0'], ['name6', '100', '', '0'] ] In this case, the '' will not be replace by None and will stay the same even when fill is enabled. IMPORTANT NOTE: If working with numerical data with possibly some missing fields, you MUST use the float type. This is because int cannot be converted to NaN by Pandas while float can. types Explained By default, all data retrieved from Google Sheets is string. However, in the case that a user would like to work with a variety of data types, they can use this option to set the data type of the pandas dataframe. The available data types are: object string int float bool datetime types can be set to any of the items on that list. Additionally, the user can determine data types for individual columns by doing the following: types: col1: int col2: string col3: bool Where the keys are the names of the columns in the data and the value is the data type of that specific column. Note: using a name of a column that does not exist will throw an error Examples With the possible structures in mind, here are a couple of examples of how a region object can look like: Example 1: name: grades start: A1 end: L4 contains_headers: true Example 2: name: expenses start: F5 end: K12 contains_headers: false headers: - Jan - Feb - Mar - Apr - May - Jun fill: true name: expenses start: A1 end: D6 contains_headers: true types: day: string date: datetime expense: float paid: bool Sheet Object The sheet object is one level above the region structure and it looks as follow: name: <string, required> name of sheet to read from in Google Sheets regions: <list of region object, required> Regions to create from the sheet Example: name: sheet1 regions: - name: grades start: A1 end: L4 contains_headers: true - name: expenses start: F5 end: K12 contains_headers: false headers: - Jan - Feb - Mar - Apr - May - Jun Overall Structure The outermost keys of the configuration must contain only two keys as follows: source_id: <string, required> ID of sheet to read sheets: <list of sheet objects, required> Example: source_id: my_sheet_id sheets: - name: sheet1 regions: - name: grades start: A1 end: L4 contains_headers: true - name: expenses start: F5 end: K12 contains_headers: false headers: - Jan - Feb - Mar - Apr - May - Jun - name: sheet2 regions: - name: some_data start: A1 end: Z10 contains_headers: true JSON Schema Structure: This is the structure used to validate the configuration using jsonschema : { \"type\": \"object\", \"properties\": { \"source_id\": {\"type\": \"string\"}, \"sheets\": { \"type\": \"array\", \"items\": {\"$ref\": \"#/$defs/sheet\"}, \"minItems\": 1, }, }, \"required\": [\"source_id\", \"sheets\"], \"$defs\": { \"region\": { \"type\": \"object\", \"properties\": { \"name\": {\"type\": \"string\"}, \"start\": {\"type\": \"string\"}, \"end\": {\"type\": \"string\"}, \"contains_headers\": {\"type\": \"boolean\"}, \"headers\": { \"type\": \"array\", \"items\": {\"type\": \"string\"}, \"minItems\": 1, }, \"fill\": {\"type\": \"boolean\"}, \"types\": { \"anyOf\": [ { \"type\": \"string\", \"enum\": [ \"object\", \"string\", \"int\", \"float\", \"bool\", \"datetime\", ], }, { \"type\": \"object\", \"additionalProperties\": { \"type\": \"string\", \"enum\": [ \"object\", \"string\", \"int\", \"float\", \"bool\", \"datetime\", ], }, }, ] }, }, \"required\": [\"name\", \"start\", \"end\", \"contains_headers\"], \"if\": {\"properties\": {\"contains_headers\": {\"const\": false}}}, \"then\": { \"required\": [\"headers\"], }, }, \"sheet\": { \"type\": \"object\", \"properties\": { \"name\": {\"type\": \"string\"}, \"regions\": { \"type\": \"array\", \"items\": {\"$ref\": \"#/$defs/region\"}, \"minItems\": 1, }, }, \"required\": [\"name\", \"regions\"], }, }, } GitHub Interactions Schema This type of schema describes the structure of configurations used to post entries to Github such as issues, pull requests, and files. Issue Schema Issue schemas follow a simple one-level structure. The following example shows the structure: type: <str, required> type of Entry, must equal \"issue\" (case sensitive) action: <str, required> action to be executed (\"create\" -> create a new issue, OR \"update\" -> add a comment to existing issue) repo: <str, required> name of repo to create the issue in. Formatted as <org>/<repo_name> body: <str, required> body of the issue or comment labels: <List[str], optional> list of labels to add to the issue # Conditional properties title: <str, conditional> title of the new issue, required if action is \"new\" number: <int, conditional> number of the existing issue, required if action is \"update\" Here are some examples of configuration to create and update issues on GitHub: Example 1: Create a new issue type: issue action: create repo: example_org/example_user title: some new issue body: example body labels: - SheetShuttle - Automated Example 2: Update issue #12 with a new comment and labels type: issue action: update repo: example_org/example_user number: 12 body: example body labels: - SheetShuttle - Automated JSON Schema Structure: { \"type\": \"object\", \"properties\": { \"type\": {\"type\": \"string\", \"const\": \"issue\"}, \"action\": {\"type\": \"string\", \"enum\": [\"create\", \"update\"]}, \"repo\": {\"type\": \"string\", \"pattern\": r\"^.+[^\\s]\\/[^\\s].+$\"}, \"body\": {\"type\": \"string\", \"minLength\": 1}, }, \"required\": [\"type\", \"action\", \"repo\", \"body\"], \"if\": {\"properties\": {\"action\": {\"const\": \"create\"}}}, \"then\": { \"properties\": { \"title\": {\"type\": \"string\", \"minLength\": 1}, \"labels\": { \"type\": \"array\", \"items\": {\"type\": \"string\", \"minLength\": 1}, \"minItems\": 1, }, }, \"required\": [\"title\"], }, \"else\": { \"properties\": { \"number\": {\"type\": \"integer\"}, \"labels\": { \"type\": \"array\", \"items\": {\"type\": \"string\", \"minLength\": 1}, \"minItems\": 1, }, }, \"required\": [\"number\"], }, } Pull Request Schema This schema structure is responsible for creating pull requests and updating them with comments. It's very similar to the Issue schema with few exceptions. type: <str, required> type of Entry, must equal \"pull request\" (case sensitive) action: <str, required> action to be executed (\"create\" -> create a new PR, OR \"update\" -> add a comment to existing PR) repo: <str, required> name of repo to create the issue in. Formatted as <org>/<repo_name> body: <str, required> body of the pull request or comment # Conditional properties if action is \"create\" title: <str, conditional> title of the new issue, required if action is \"new\" base: <str,conditional> name of the branch to merge into, required if action is \"new\" head: <str,conditional> name of the branch to merge from, required if action is \"new\" # Conditional properties if action is \"update\" number: <int, conditional> number of the existing pull request, required if action is \"update\" Here are some examples of configuration to create and update issues on GitHub: Example 1: Create a new pull request type: pull request action: create repo: example_org/example_user title: some new pull request body: example body base: main head: my_branch Example 2: Update pull request #5 with a new comment type: pull request action: update repo: example_org/example_user number: 12 body: example body JSON Schema Structure: { \"type\": \"object\", \"properties\": { \"type\": {\"type\": \"string\", \"const\": \"pull request\"}, \"action\": {\"type\": \"string\", \"enum\": [\"create\", \"update\"]}, \"repo\": {\"type\": \"string\", \"pattern\": r\"^.+[^\\s]\\/[^\\s].+$\"}, \"body\": {\"type\": \"string\", \"minLength\": 1}, }, \"required\": [\"type\", \"action\", \"repo\", \"body\"], \"if\": {\"properties\": {\"action\": {\"const\": \"create\"}}}, \"then\": { \"properties\": { \"title\": {\"type\": \"string\", \"minLength\": 1}, \"base\": {\"type\": \"string\", \"minLength\": 1}, \"head\": {\"type\": \"string\", \"minLength\": 1}, }, \"required\": [\"title\", \"base\", \"head\"], }, \"else\": { \"properties\": { \"number\": {\"type\": \"integer\"}, }, \"required\": [\"number\"], }, } File Schema This schema structure is responsible for creating files and updating them as well as replacing them entirely. Unlike the issue and pull request schemas, this one supports 3 actions create , update , and replace . While update preserves the ordinal content of the file, replace erases the old content. type: <str, required> type of Entry, must equal \"file\" (case sensitive) action: <str, required> action to be executed (\"create\" OR \"update\" OR \"replace\") repo: <str, required> name of repo to create the issue in. Formatted as <org>/<repo_name> path: <str, required> path to the file to be impacted content: <str, required> content of the file branch: <str, required> name of the branch that the file exists in commit_message: <str, optional> the commit message to used when executing the action Here are some examples of configuration to create, update, and replace files: Example 1: Create a new markdown file type: file action: create repo: example_org/example_user path: folder/file.md content: \"# Hello world!\" branch: main commit_message: add example markdown file Example 2: Update an existing markdown file type: file action: update repo: example_org/example_user path: folder/file.md content: this is an example branch: main commit_message: update example markdown file Example 3: Replace an existing markdown file type: file action: replace repo: example_org/example_user path: folder/file.md content: \"# Section 1\" branch: main commit_message: replace example markdown file JSON Schema Structure: { \"type\": \"object\", \"properties\": { \"type\": {\"type\": \"string\", \"const\": \"file\"}, \"action\": {\"type\": \"string\", \"enum\": [\"create\", \"update\", \"replace\"]}, \"repo\": {\"type\": \"string\", \"pattern\": r\"^.+[^\\s]\\/[^\\s].+$\"}, \"path\": {\"type\": \"string\", \"minLength\": 1}, \"content\": {\"type\": \"string\", \"minLength\": 1}, \"branch\": {\"type\": \"string\", \"minLength\": 1}, \"commit_message\": {\"type\": \"string\", \"minLength\": 1}, }, \"required\": [\"type\", \"action\", \"repo\", \"path\", \"content\", \"branch\"], }","title":"Schemas"},{"location":"Schemas/#config-schemas","text":"The examples shown here demonstrate the schemas for configuration read by SheetShuttle. In order for the tool to function with no errors, user written configuration must follow the specified format. Config Schemas Sheets Schema Defining Objects Region Object contains_headers Explained fill Explained types Explained Examples Sheet Object Overall Structure GitHub Interactions Schema Issue Schema Pull Request Schema File Schema","title":"Config Schemas"},{"location":"Schemas/#sheets-schema","text":"Sheets schema describe the format for configuration used to retrieve Google Sheet data.","title":"Sheets Schema"},{"location":"Schemas/#defining-objects","text":"There are two main nested object structures used in the Sheets schema.","title":"Defining Objects"},{"location":"Schemas/#region-object","text":"This is the simplest object that does not contain complex nested objects in it. It has the following general structure: name: <string, required> name of the region to create start: <string, required> cell to start from (eg. A1) end: <string, required> cell to end at (eg. H12) contains_headers: <boolean, required> if selected range contains headers in the first row headers: <list of strings, conditional> headers to be used, only required if contains_headers is false fill: <boolean, optional> fill the region with `None` if there are missing values. Defaults to false types: <string or object, optional> data type to use for the whole region or for specific columns. Defaults to `string` Some values in this structure are a bit ambiguous, the following section will provide further explanation on their usage:","title":"Region Object"},{"location":"Schemas/#contains_headers-explained","text":"In many cases, the region being retrieved already contains the headers to the data. Set this option to true in order to set the column headers of the resulting Pandas dataframe equal to the first row of the data. In the case that the data does not contain headers, another value headers is required by the schema. It should be a list of strings with the headers of the data. NOTE: The length of the headers list must match the number of columns in the data. Otherwise a Pandas error will be thrown.","title":"contains_headers Explained"},{"location":"Schemas/#fill-explained","text":"SheetShuttle attempts to deal with missing data, but many limitations exist. The following screenshot shows a dataset with empty cells. Let's see how SheetShuttle allows you to deal with it. When retrieved from the Google Sheets API, the data looks as follows: [ ['Student Name', 'EE1-1', 'EE1-2', 'EE1-3'], ['name1', '85', '0'], ['name2', '100', '1'], ['name3', '100', '1'], ['name4', '100', '0'], ['name5', '100', '1'], ['name6', '100', '1'] ] As seen in the sample output, the missing data simply does not show up in the returned value from the API. By enabling fill , the data is converted to the following and then a dataframe is created using it. [ ['Student Name', 'EE1-1', 'EE1-2', 'EE1-3'], ['name1', '85', '0', None], ['name2', '100', '1', None], ['name3', '100', '1', None], ['name4', '100', '0', None], ['name5', '100', '1', None], ['name6', '100', '1', None] ] The same applies to empty rows, where a row full of None is appended in some cases. Example: [ ['Student Name', 'EE1-1', 'EE1-2', 'EE1-3'], ['name1', '85', '0', None], ['name2', '100', '1', None], ['name3', '100', '1', None], ['name4', '100', '0', None], ['name5', '100', '1', None], ['name6', '100', '1', None], [None, None, None, None] ] None will then get converted to Not a Number NaN values in the resulting Pandas dataframe. A problem with this approach is the following: Using a similar example where the missing data is not in the last row/column as seen here: The resulting data from the API is the following: [ ['Student Name', 'EE1-1', 'EE1-2', 'EE1-3'], ['name1', '85', '', '0'], ['name2', '100', '', '1'], ['name3', '100', '', '0'], ['name4', '100', '', '1'], ['name5', '100', '', '0'], ['name6', '100', '', '0'] ] In this case, the '' will not be replace by None and will stay the same even when fill is enabled. IMPORTANT NOTE: If working with numerical data with possibly some missing fields, you MUST use the float type. This is because int cannot be converted to NaN by Pandas while float can.","title":"fill Explained"},{"location":"Schemas/#types-explained","text":"By default, all data retrieved from Google Sheets is string. However, in the case that a user would like to work with a variety of data types, they can use this option to set the data type of the pandas dataframe. The available data types are: object string int float bool datetime types can be set to any of the items on that list. Additionally, the user can determine data types for individual columns by doing the following: types: col1: int col2: string col3: bool Where the keys are the names of the columns in the data and the value is the data type of that specific column. Note: using a name of a column that does not exist will throw an error","title":"types Explained"},{"location":"Schemas/#examples","text":"With the possible structures in mind, here are a couple of examples of how a region object can look like: Example 1: name: grades start: A1 end: L4 contains_headers: true Example 2: name: expenses start: F5 end: K12 contains_headers: false headers: - Jan - Feb - Mar - Apr - May - Jun fill: true name: expenses start: A1 end: D6 contains_headers: true types: day: string date: datetime expense: float paid: bool","title":"Examples"},{"location":"Schemas/#sheet-object","text":"The sheet object is one level above the region structure and it looks as follow: name: <string, required> name of sheet to read from in Google Sheets regions: <list of region object, required> Regions to create from the sheet Example: name: sheet1 regions: - name: grades start: A1 end: L4 contains_headers: true - name: expenses start: F5 end: K12 contains_headers: false headers: - Jan - Feb - Mar - Apr - May - Jun","title":"Sheet Object"},{"location":"Schemas/#overall-structure","text":"The outermost keys of the configuration must contain only two keys as follows: source_id: <string, required> ID of sheet to read sheets: <list of sheet objects, required> Example: source_id: my_sheet_id sheets: - name: sheet1 regions: - name: grades start: A1 end: L4 contains_headers: true - name: expenses start: F5 end: K12 contains_headers: false headers: - Jan - Feb - Mar - Apr - May - Jun - name: sheet2 regions: - name: some_data start: A1 end: Z10 contains_headers: true JSON Schema Structure: This is the structure used to validate the configuration using jsonschema : { \"type\": \"object\", \"properties\": { \"source_id\": {\"type\": \"string\"}, \"sheets\": { \"type\": \"array\", \"items\": {\"$ref\": \"#/$defs/sheet\"}, \"minItems\": 1, }, }, \"required\": [\"source_id\", \"sheets\"], \"$defs\": { \"region\": { \"type\": \"object\", \"properties\": { \"name\": {\"type\": \"string\"}, \"start\": {\"type\": \"string\"}, \"end\": {\"type\": \"string\"}, \"contains_headers\": {\"type\": \"boolean\"}, \"headers\": { \"type\": \"array\", \"items\": {\"type\": \"string\"}, \"minItems\": 1, }, \"fill\": {\"type\": \"boolean\"}, \"types\": { \"anyOf\": [ { \"type\": \"string\", \"enum\": [ \"object\", \"string\", \"int\", \"float\", \"bool\", \"datetime\", ], }, { \"type\": \"object\", \"additionalProperties\": { \"type\": \"string\", \"enum\": [ \"object\", \"string\", \"int\", \"float\", \"bool\", \"datetime\", ], }, }, ] }, }, \"required\": [\"name\", \"start\", \"end\", \"contains_headers\"], \"if\": {\"properties\": {\"contains_headers\": {\"const\": false}}}, \"then\": { \"required\": [\"headers\"], }, }, \"sheet\": { \"type\": \"object\", \"properties\": { \"name\": {\"type\": \"string\"}, \"regions\": { \"type\": \"array\", \"items\": {\"$ref\": \"#/$defs/region\"}, \"minItems\": 1, }, }, \"required\": [\"name\", \"regions\"], }, }, }","title":"Overall Structure"},{"location":"Schemas/#github-interactions-schema","text":"This type of schema describes the structure of configurations used to post entries to Github such as issues, pull requests, and files.","title":"GitHub Interactions Schema"},{"location":"Schemas/#issue-schema","text":"Issue schemas follow a simple one-level structure. The following example shows the structure: type: <str, required> type of Entry, must equal \"issue\" (case sensitive) action: <str, required> action to be executed (\"create\" -> create a new issue, OR \"update\" -> add a comment to existing issue) repo: <str, required> name of repo to create the issue in. Formatted as <org>/<repo_name> body: <str, required> body of the issue or comment labels: <List[str], optional> list of labels to add to the issue # Conditional properties title: <str, conditional> title of the new issue, required if action is \"new\" number: <int, conditional> number of the existing issue, required if action is \"update\" Here are some examples of configuration to create and update issues on GitHub: Example 1: Create a new issue type: issue action: create repo: example_org/example_user title: some new issue body: example body labels: - SheetShuttle - Automated Example 2: Update issue #12 with a new comment and labels type: issue action: update repo: example_org/example_user number: 12 body: example body labels: - SheetShuttle - Automated JSON Schema Structure: { \"type\": \"object\", \"properties\": { \"type\": {\"type\": \"string\", \"const\": \"issue\"}, \"action\": {\"type\": \"string\", \"enum\": [\"create\", \"update\"]}, \"repo\": {\"type\": \"string\", \"pattern\": r\"^.+[^\\s]\\/[^\\s].+$\"}, \"body\": {\"type\": \"string\", \"minLength\": 1}, }, \"required\": [\"type\", \"action\", \"repo\", \"body\"], \"if\": {\"properties\": {\"action\": {\"const\": \"create\"}}}, \"then\": { \"properties\": { \"title\": {\"type\": \"string\", \"minLength\": 1}, \"labels\": { \"type\": \"array\", \"items\": {\"type\": \"string\", \"minLength\": 1}, \"minItems\": 1, }, }, \"required\": [\"title\"], }, \"else\": { \"properties\": { \"number\": {\"type\": \"integer\"}, \"labels\": { \"type\": \"array\", \"items\": {\"type\": \"string\", \"minLength\": 1}, \"minItems\": 1, }, }, \"required\": [\"number\"], }, }","title":"Issue Schema"},{"location":"Schemas/#pull-request-schema","text":"This schema structure is responsible for creating pull requests and updating them with comments. It's very similar to the Issue schema with few exceptions. type: <str, required> type of Entry, must equal \"pull request\" (case sensitive) action: <str, required> action to be executed (\"create\" -> create a new PR, OR \"update\" -> add a comment to existing PR) repo: <str, required> name of repo to create the issue in. Formatted as <org>/<repo_name> body: <str, required> body of the pull request or comment # Conditional properties if action is \"create\" title: <str, conditional> title of the new issue, required if action is \"new\" base: <str,conditional> name of the branch to merge into, required if action is \"new\" head: <str,conditional> name of the branch to merge from, required if action is \"new\" # Conditional properties if action is \"update\" number: <int, conditional> number of the existing pull request, required if action is \"update\" Here are some examples of configuration to create and update issues on GitHub: Example 1: Create a new pull request type: pull request action: create repo: example_org/example_user title: some new pull request body: example body base: main head: my_branch Example 2: Update pull request #5 with a new comment type: pull request action: update repo: example_org/example_user number: 12 body: example body JSON Schema Structure: { \"type\": \"object\", \"properties\": { \"type\": {\"type\": \"string\", \"const\": \"pull request\"}, \"action\": {\"type\": \"string\", \"enum\": [\"create\", \"update\"]}, \"repo\": {\"type\": \"string\", \"pattern\": r\"^.+[^\\s]\\/[^\\s].+$\"}, \"body\": {\"type\": \"string\", \"minLength\": 1}, }, \"required\": [\"type\", \"action\", \"repo\", \"body\"], \"if\": {\"properties\": {\"action\": {\"const\": \"create\"}}}, \"then\": { \"properties\": { \"title\": {\"type\": \"string\", \"minLength\": 1}, \"base\": {\"type\": \"string\", \"minLength\": 1}, \"head\": {\"type\": \"string\", \"minLength\": 1}, }, \"required\": [\"title\", \"base\", \"head\"], }, \"else\": { \"properties\": { \"number\": {\"type\": \"integer\"}, }, \"required\": [\"number\"], }, }","title":"Pull Request Schema"},{"location":"Schemas/#file-schema","text":"This schema structure is responsible for creating files and updating them as well as replacing them entirely. Unlike the issue and pull request schemas, this one supports 3 actions create , update , and replace . While update preserves the ordinal content of the file, replace erases the old content. type: <str, required> type of Entry, must equal \"file\" (case sensitive) action: <str, required> action to be executed (\"create\" OR \"update\" OR \"replace\") repo: <str, required> name of repo to create the issue in. Formatted as <org>/<repo_name> path: <str, required> path to the file to be impacted content: <str, required> content of the file branch: <str, required> name of the branch that the file exists in commit_message: <str, optional> the commit message to used when executing the action Here are some examples of configuration to create, update, and replace files: Example 1: Create a new markdown file type: file action: create repo: example_org/example_user path: folder/file.md content: \"# Hello world!\" branch: main commit_message: add example markdown file Example 2: Update an existing markdown file type: file action: update repo: example_org/example_user path: folder/file.md content: this is an example branch: main commit_message: update example markdown file Example 3: Replace an existing markdown file type: file action: replace repo: example_org/example_user path: folder/file.md content: \"# Section 1\" branch: main commit_message: replace example markdown file JSON Schema Structure: { \"type\": \"object\", \"properties\": { \"type\": {\"type\": \"string\", \"const\": \"file\"}, \"action\": {\"type\": \"string\", \"enum\": [\"create\", \"update\", \"replace\"]}, \"repo\": {\"type\": \"string\", \"pattern\": r\"^.+[^\\s]\\/[^\\s].+$\"}, \"path\": {\"type\": \"string\", \"minLength\": 1}, \"content\": {\"type\": \"string\", \"minLength\": 1}, \"branch\": {\"type\": \"string\", \"minLength\": 1}, \"commit_message\": {\"type\": \"string\", \"minLength\": 1}, }, \"required\": [\"type\", \"action\", \"repo\", \"path\", \"content\", \"branch\"], }","title":"File Schema"},{"location":"Tutorial/","text":"Getting Started with SheetShuttle Getting Started with SheetShuttle Setting Up and Running Your Plugin Setup The Path and Plugin Name Add a run() Function Importing from SheetShuttle Using the Google Sheets API Ensure that All Authentication Variables are Available and Accessible Share the Google Sheets file(s) with the created service account Write YAML configuration used to retrieved data Call sheet_collector from the plugin Using the GitHub API Add GitHub Access Token Write or Generate YAML Configuration Call GithubManager from Your Plugin SheetShuttle provides a simple infrastructure to interact with Google Sheets API as well as GitHub API. It gives the user the ability to create custom plugins that integrate with the tool's workflow. This tutorial will provide some examples and code snippets to get started with SheetShuttle. Setting Up and Running Your Plugin There are few requirements to be met before diving in developing your plugin, the following tasks are important to make sure SheetShuttle can find and run your custom plugin: Setup The Path and Plugin Name By default, SheetShuttle searches the plugins directory for the default plugin named default.py . If you wish to run your own plugin, you can create a Python file in any directory on your system. However, the directory and name of the this Python file must be passed into SheetShuttle's CLI in order to be detected. For example, if the plugin my_plugin.py was created in ../projects/my_plugins/ , then the CLI argument for plugin_name would be my_plugin ( Note that .py is omitted) and the value of plugins_directory argument would be ../projects/my_plugins/ Add a run() Function SheetShuttle assumes that a run() function exists in your plugin which gets called in order to execute your custom code. To prevent errors while loading and running the plugin, this function signature is required for every plugin. def run(sheets_keys_file, sheets_config_directory, **kwargs): # rest of your plugin code TODO: More information is needed here after full support is added Importing from SheetShuttle In order to use the functionalities in SheetShuttle's infrastructure, your plugin should import the needed modules. # If collecting data from Google Sheets, sheet_collector should be imported from sheetshuttle import sheet_collector # To manipulate collected data, pandas should also be imported import pandas as pd # If Working with GitHub, the following modules should also be imported from sheetshuttle import github_interaction from github import Github Using the Google Sheets API The sheets_collector module is responsible for retrieving data from Google Sheets and organizing it in nested objects such as sheets, and regions. In order to make API request calls, sheets_collector relies on user-written YAML configuration that follow the structure specified in the schemas guidline . In this section, the structure of the retrieved data is discussed as well as the supported functions of the sheets_collector module. Ensure that All Authentication Variables are Available and Accessible There are two main ways to provide Google Sheets authentication tokens to SheetShuttle. The tokens are obtained after setting up a service account. Authentication information can be stored in a .json file or as part of a .env file. This process is discussed in Google Sheets Service Account section of the README file. Regardless of which approach is used, the name of the file should be passed as a CLI argument to SheetShuttle Share the Google Sheets file(s) with the created service account Before attempting to access the data in the Google Sheets file, the created service account must have access to the file. To do that please follow these instructions . Write YAML configuration used to retrieved data TODO: add and cite API References In this step, the user outlines the structure that data should be organized after being collected from Google Sheets. Various objects are created and store in different formats. This section concerns how configuration is formatted and read, however, more information regarding what each object supports are discussed in API references. In general, each Google Sheets file requires it's own YAML configuration file, so in the case that the user is reading multiple Google Sheet files, there needs to be more than one YAML file in the configuration directory. The example below shows configuration for one Google Sheets file and splits it up into multiple sheets and regions. source_id: my_sheet_id sheets: - name: sheet1 regions: - name: grades start: A1 end: L4 contains_headers: true - name: expenses start: F5 end: K12 contains_headers: false headers: - Jan - Feb - Mar - Apr - May - Jun - name: sheet2 regions: - name: some_data start: A1 end: Z10 contains_headers: true Here is a general description of the keys listed in the configuration: source_id : The ID of the Google Sheet file should be pasted as this value, it's typically found between the /d/ and /edit in the URL of the file. The pasted ID should not include the /d/ and /edit when pasted into the configuration. sheets : this key should include a list of sheet objects with two main keys, the name of the sheet, and a list of regions to break it down into. The data inside each region is stored as a Pandas DataFrame With that in mind, the above configuration does the following: In general retrieve the data from the file with ID my_sheet_id Create two regions from sheet1 First region is named grades , where data bounded by cell A1 and L4 are stored with the first row of the data as headers. Second region is named expenses and it stores data bound by cell F5 and K12 . The headers of the data frame are custom and they're listed in the headers list. Create one region from sheet2 named some_data which is bound by A1 and Z10 Call sheet_collector from the plugin Once all previous setup steps are completed, you can begin writing your plugin and utilizing the infrastructure of SheetShuttle. A quick way to get started is the simple code snippet below which initializes a SheetCollector object and executes the configuration to retrieve and store data from Google Sheets. from sheetshuttle import sheet_collector my_collector = sheet_collector.SheetCollector() my_collector.collect_files() Note that initializing a SheetCollector object accepts the following optional arguments: key_file : path to the file containing Google Sheets API authentication tokens. The file can be either a .env or .json format. The default value of this argument is .env . sources_dir : path to the directory containing all the YAML configuration to be read. The default value is config/sheet_sources Once collect_files() finishes running, my_collector.sheets_data instance variable is populated with all the collected data. The variable is a dictionary where sheet names are keys in the dictionary and the values are corresponding Sheet objects. Using the GitHub API Similar to using the Google Sheets API, the GitHub API relies on authentication token as well as user written or plugin generated configuration to execute all the requests. The following sections describe the needed steps to set up and use the GitHub API. Add GitHub Access Token The GitHub Access Token section in README discusses how to generate a GitHub token and make it accessible to SheetShuttle. Without the token, SheetShuttle will not be able to authenticate with the API and post entries such as issues, pull requests, or files. Write or Generate YAML Configuration GitHub interactions also uses YAML configuration to execute API requests and post entries to a GitHub repository. This configuration can be user written or automatically generated by your plugin. The configuration must follow the structure described in the schemas guide but an example is also shown and explained below. The configuration should be structured as a list of Entry objects that contain the type of entry as well as the action to be done. Different entries support different actions and attributes in their structure. For more information, refer to the schemas guide. # Create an issue # labels are optional - type: issue action: create repo: repo_org/repo_name title: some new issue body: test body labels: - label1 - label2 # update/comment on an issue # Number of issue to update must be used instead of title # New labels can be added - type: issue action: update repo: repo_org/repo_name number: 1 body: test body labels: - label1 - label2 # Create a pull request # base is the name of branch to merge into # head is the name of branch to merge from - type: pull request action: create repo: repo_org/repo_name title: test create pull request body: Test pull request create base: main head: test_branch # Update/add comment on a pull request # Number of pull request is used instead of title - type: pull request action: update repo: repo_org/repo_name number: 2 body: Test pull request create # Create a new file in a branch # the path must include the format of the file to be created - type: file action: create repo: repo_org/repo_name path: folder1/file2.txt content: hello world! branch: main commit_message: sample commit message # Append to an existing file # This action appends the new content to the old content of the file - type: file action: update repo: repo_org/repo_name path: folder1/file2.txt content: hello world! branch: main commit_message: sample commit message # Replace an existing file # This action completely erases the old content of the file # and replaces it with the new content - type: file action: replace repo: repo_org/repo_name path: folder1/file2.txt content: hello world! branch: main commit_message: sample commit message Call GithubManager from Your Plugin Once configuration has been written or automatically generated, a GitHubManager object can be initialized in your plugin to collect and parse the configuration. The object also supports the ability to post the entries. The code snippet below shows an example of how it can be used. from sheetshuttle import github_interaction my_manager = github_interaction.GitHubManager() my_manager.collect_config() # All collected entries can be posted at once my_manager.post_all() # OR they can be posted individually by type my_manager.post_issues() my_manager.post_pull_requests() my_manager.post_files() Note that when initializing a GitHubManager object, two optional arguments can be accepted: key_file : the path to the file containing the GitHub token. By default the the value of this argument is .env causing the manager to look for the token in environment variables. Tokens can be stored in .json files or as environment variables. sources_dir : the path to the directory containing YAML configuration files for the GitHubManager object. All YAML files are collected and parsed to create corresponding Entry objects. By default, the value of this argument is config/github_interactions .","title":"Tutorial"},{"location":"Tutorial/#getting-started-with-sheetshuttle","text":"Getting Started with SheetShuttle Setting Up and Running Your Plugin Setup The Path and Plugin Name Add a run() Function Importing from SheetShuttle Using the Google Sheets API Ensure that All Authentication Variables are Available and Accessible Share the Google Sheets file(s) with the created service account Write YAML configuration used to retrieved data Call sheet_collector from the plugin Using the GitHub API Add GitHub Access Token Write or Generate YAML Configuration Call GithubManager from Your Plugin SheetShuttle provides a simple infrastructure to interact with Google Sheets API as well as GitHub API. It gives the user the ability to create custom plugins that integrate with the tool's workflow. This tutorial will provide some examples and code snippets to get started with SheetShuttle.","title":"Getting Started with SheetShuttle"},{"location":"Tutorial/#setting-up-and-running-your-plugin","text":"There are few requirements to be met before diving in developing your plugin, the following tasks are important to make sure SheetShuttle can find and run your custom plugin:","title":"Setting Up and Running Your Plugin"},{"location":"Tutorial/#setup-the-path-and-plugin-name","text":"By default, SheetShuttle searches the plugins directory for the default plugin named default.py . If you wish to run your own plugin, you can create a Python file in any directory on your system. However, the directory and name of the this Python file must be passed into SheetShuttle's CLI in order to be detected. For example, if the plugin my_plugin.py was created in ../projects/my_plugins/ , then the CLI argument for plugin_name would be my_plugin ( Note that .py is omitted) and the value of plugins_directory argument would be ../projects/my_plugins/","title":"Setup The Path and Plugin Name"},{"location":"Tutorial/#add-a-run-function","text":"SheetShuttle assumes that a run() function exists in your plugin which gets called in order to execute your custom code. To prevent errors while loading and running the plugin, this function signature is required for every plugin. def run(sheets_keys_file, sheets_config_directory, **kwargs): # rest of your plugin code TODO: More information is needed here after full support is added","title":"Add a run() Function"},{"location":"Tutorial/#importing-from-sheetshuttle","text":"In order to use the functionalities in SheetShuttle's infrastructure, your plugin should import the needed modules. # If collecting data from Google Sheets, sheet_collector should be imported from sheetshuttle import sheet_collector # To manipulate collected data, pandas should also be imported import pandas as pd # If Working with GitHub, the following modules should also be imported from sheetshuttle import github_interaction from github import Github","title":"Importing from SheetShuttle"},{"location":"Tutorial/#using-the-google-sheets-api","text":"The sheets_collector module is responsible for retrieving data from Google Sheets and organizing it in nested objects such as sheets, and regions. In order to make API request calls, sheets_collector relies on user-written YAML configuration that follow the structure specified in the schemas guidline . In this section, the structure of the retrieved data is discussed as well as the supported functions of the sheets_collector module.","title":"Using the Google Sheets API"},{"location":"Tutorial/#ensure-that-all-authentication-variables-are-available-and-accessible","text":"There are two main ways to provide Google Sheets authentication tokens to SheetShuttle. The tokens are obtained after setting up a service account. Authentication information can be stored in a .json file or as part of a .env file. This process is discussed in Google Sheets Service Account section of the README file. Regardless of which approach is used, the name of the file should be passed as a CLI argument to SheetShuttle","title":"Ensure that All Authentication Variables are Available and Accessible"},{"location":"Tutorial/#share-the-google-sheets-files-with-the-created-service-account","text":"Before attempting to access the data in the Google Sheets file, the created service account must have access to the file. To do that please follow these instructions .","title":"Share the Google Sheets file(s) with the created service account"},{"location":"Tutorial/#write-yaml-configuration-used-to-retrieved-data","text":"TODO: add and cite API References In this step, the user outlines the structure that data should be organized after being collected from Google Sheets. Various objects are created and store in different formats. This section concerns how configuration is formatted and read, however, more information regarding what each object supports are discussed in API references. In general, each Google Sheets file requires it's own YAML configuration file, so in the case that the user is reading multiple Google Sheet files, there needs to be more than one YAML file in the configuration directory. The example below shows configuration for one Google Sheets file and splits it up into multiple sheets and regions. source_id: my_sheet_id sheets: - name: sheet1 regions: - name: grades start: A1 end: L4 contains_headers: true - name: expenses start: F5 end: K12 contains_headers: false headers: - Jan - Feb - Mar - Apr - May - Jun - name: sheet2 regions: - name: some_data start: A1 end: Z10 contains_headers: true Here is a general description of the keys listed in the configuration: source_id : The ID of the Google Sheet file should be pasted as this value, it's typically found between the /d/ and /edit in the URL of the file. The pasted ID should not include the /d/ and /edit when pasted into the configuration. sheets : this key should include a list of sheet objects with two main keys, the name of the sheet, and a list of regions to break it down into. The data inside each region is stored as a Pandas DataFrame With that in mind, the above configuration does the following: In general retrieve the data from the file with ID my_sheet_id Create two regions from sheet1 First region is named grades , where data bounded by cell A1 and L4 are stored with the first row of the data as headers. Second region is named expenses and it stores data bound by cell F5 and K12 . The headers of the data frame are custom and they're listed in the headers list. Create one region from sheet2 named some_data which is bound by A1 and Z10","title":"Write YAML configuration used to retrieved data"},{"location":"Tutorial/#call-sheet_collector-from-the-plugin","text":"Once all previous setup steps are completed, you can begin writing your plugin and utilizing the infrastructure of SheetShuttle. A quick way to get started is the simple code snippet below which initializes a SheetCollector object and executes the configuration to retrieve and store data from Google Sheets. from sheetshuttle import sheet_collector my_collector = sheet_collector.SheetCollector() my_collector.collect_files() Note that initializing a SheetCollector object accepts the following optional arguments: key_file : path to the file containing Google Sheets API authentication tokens. The file can be either a .env or .json format. The default value of this argument is .env . sources_dir : path to the directory containing all the YAML configuration to be read. The default value is config/sheet_sources Once collect_files() finishes running, my_collector.sheets_data instance variable is populated with all the collected data. The variable is a dictionary where sheet names are keys in the dictionary and the values are corresponding Sheet objects.","title":"Call sheet_collector from the plugin"},{"location":"Tutorial/#using-the-github-api","text":"Similar to using the Google Sheets API, the GitHub API relies on authentication token as well as user written or plugin generated configuration to execute all the requests. The following sections describe the needed steps to set up and use the GitHub API.","title":"Using the GitHub API"},{"location":"Tutorial/#add-github-access-token","text":"The GitHub Access Token section in README discusses how to generate a GitHub token and make it accessible to SheetShuttle. Without the token, SheetShuttle will not be able to authenticate with the API and post entries such as issues, pull requests, or files.","title":"Add GitHub Access Token"},{"location":"Tutorial/#write-or-generate-yaml-configuration","text":"GitHub interactions also uses YAML configuration to execute API requests and post entries to a GitHub repository. This configuration can be user written or automatically generated by your plugin. The configuration must follow the structure described in the schemas guide but an example is also shown and explained below. The configuration should be structured as a list of Entry objects that contain the type of entry as well as the action to be done. Different entries support different actions and attributes in their structure. For more information, refer to the schemas guide. # Create an issue # labels are optional - type: issue action: create repo: repo_org/repo_name title: some new issue body: test body labels: - label1 - label2 # update/comment on an issue # Number of issue to update must be used instead of title # New labels can be added - type: issue action: update repo: repo_org/repo_name number: 1 body: test body labels: - label1 - label2 # Create a pull request # base is the name of branch to merge into # head is the name of branch to merge from - type: pull request action: create repo: repo_org/repo_name title: test create pull request body: Test pull request create base: main head: test_branch # Update/add comment on a pull request # Number of pull request is used instead of title - type: pull request action: update repo: repo_org/repo_name number: 2 body: Test pull request create # Create a new file in a branch # the path must include the format of the file to be created - type: file action: create repo: repo_org/repo_name path: folder1/file2.txt content: hello world! branch: main commit_message: sample commit message # Append to an existing file # This action appends the new content to the old content of the file - type: file action: update repo: repo_org/repo_name path: folder1/file2.txt content: hello world! branch: main commit_message: sample commit message # Replace an existing file # This action completely erases the old content of the file # and replaces it with the new content - type: file action: replace repo: repo_org/repo_name path: folder1/file2.txt content: hello world! branch: main commit_message: sample commit message","title":"Write or Generate YAML Configuration"},{"location":"Tutorial/#call-githubmanager-from-your-plugin","text":"Once configuration has been written or automatically generated, a GitHubManager object can be initialized in your plugin to collect and parse the configuration. The object also supports the ability to post the entries. The code snippet below shows an example of how it can be used. from sheetshuttle import github_interaction my_manager = github_interaction.GitHubManager() my_manager.collect_config() # All collected entries can be posted at once my_manager.post_all() # OR they can be posted individually by type my_manager.post_issues() my_manager.post_pull_requests() my_manager.post_files() Note that when initializing a GitHubManager object, two optional arguments can be accepted: key_file : the path to the file containing the GitHub token. By default the the value of this argument is .env causing the manager to look for the token in environment variables. Tokens can be stored in .json files or as environment variables. sources_dir : the path to the directory containing YAML configuration files for the GitHubManager object. All YAML files are collected and parsed to create corresponding Entry objects. By default, the value of this argument is config/github_interactions .","title":"Call GithubManager from Your Plugin"}]}